<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>@LTU_scripts.hmi.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://mousquetaires.sharepoint.com/sites/Portail-AgroM/" target="_blank" class="menu-item" id="portail-agrom" >Portail AgroMousquetaires</a></h2><h2><a href="https://mousquetaires.sharepoint.com/sites/AgroM_Portail_OT" target="_blank" class="menu-item" id="portail-ot" >Portail OT </a></h2><h2><a href="https://github.com/Thomas-dvpt/ltu-jsdocs-generator.git" target="_blank" class="menu-item" id="repository" >GitHub Repo </a></h2><h3>Namespaces</h3><ul><li><a href="general.html">general</a><ul class='methods'><li data-type='method'><a href="general.html#.general_logTrace">general_logTrace</a></li><li data-type='method'><a href="general.html#.general_userAudit">general_userAudit</a></li><li data-type='method'><a href="general.html#.general_waitForUiElement">general_waitForUiElement</a></li></ul></li><li><a href="global.html">global</a><ul class='methods'><li data-type='method'><a href="global.html#._config">_config</a></li><li data-type='method'><a href="global.html#._initRuntime">_initRuntime</a></li></ul></li><li><a href="screenHistory.html">screenHistory</a><ul class='methods'><li data-type='method'><a href="screenHistory.html#.screenHistory_changeScreen">screenHistory_changeScreen</a></li><li data-type='method'><a href="screenHistory.html#.screenHistory_createStackDataset">screenHistory_createStackDataset</a></li><li data-type='method'><a href="screenHistory.html#.screenHistory_goBackScreen">screenHistory_goBackScreen</a></li><li data-type='method'><a href="screenHistory.html#.screenHistory_goForwardScreen">screenHistory_goForwardScreen</a></li><li data-type='method'><a href="screenHistory.html#.screenHistory_updateButtonState">screenHistory_updateButtonState</a></li></ul></li><li><a href="screenLayout.html">screenLayout</a><ul class='methods'><li data-type='method'><a href="screenLayout.html#.screenLayout_getHierarchyFirstLevel()">screenLayout_getHierarchyFirstLevel()</a></li><li data-type='method'><a href="screenLayout.html#.screenLayout_getHierarchyInfos">screenLayout_getHierarchyInfos</a></li><li data-type='method'><a href="screenLayout.html#.screenLayout_setHierarchyNodes">screenLayout_setHierarchyNodes</a></li><li data-type='method'><a href="screenLayout.html#.screenLayout_setSecondLevelNavigation">screenLayout_setSecondLevelNavigation</a></li><li data-type='method'><a href="screenLayout.html#.screenLayout_setTopLevelNavigation">screenLayout_setTopLevelNavigation</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#CHECK_INTERVAL">CHECK_INTERVAL</a></li><li><a href="global.html#MAX_BP">MAX_BP</a></li><li><a href="global.html#MAX_BP_EXTENDED">MAX_BP_EXTENDED</a></li><li><a href="global.html#MAX_HISTORY_SIZE">MAX_HISTORY_SIZE</a></li><li><a href="global.html#PLANT_HIERARCHY_PATH">PLANT_HIERARCHY_PATH</a></li><li><a href="global.html#PREFIX_BP">PREFIX_BP</a></li><li><a href="global.html#SCREEN_EXTENDED_NAV_PATH">SCREEN_EXTENDED_NAV_PATH</a></li><li><a href="global.html#SCREEN_MAIN">SCREEN_MAIN</a></li><li><a href="global.html#SCREEN_TOP_LVL_NAV_PATH">SCREEN_TOP_LVL_NAV_PATH</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">@LTU_scripts.hmi.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module LTU_scripts
 * @file Le module @LTU_script.js est un composant essentiel de la bibliothèque LTU (Library Tia Unified).
 *       Il propose un ensemble de fonctions utilisées dans les vues et faceplates d'un projet LTU. 
 * @copyright Thomas HEURTAULT &lt;thomas.heurtault@mousquetaires.com>
 * @version 1.0.0
 */
/**
 * @namespace global
 * @description Description de mon nameSpace
 */
/**
 * 
 * @namespace general
 * @description Description de mon nameSpace
 */
/**
* @namespace screenLayout
* @description Description de mon nameSpace
*/
/**
* @namespace screenHistory
* @description Description de mon nameSpace
*/

/**
/*&lt;auto-generated>
***End of Global definition area***
Changes to this comment may cause incorrect behavior during document based import.
&lt;/auto-generated>*/
/**
 * 
 * @memberOf general
 * @function general_logTrace
 * @author Thomas HEURTAULT 
 * @version 3.0.1
 * @description Enregistre des messages de trace avec des paramètres d'entrée spécifiques
 *
* @param {string} functionName - Nom de la fonction à journaliser
* @param {string} type - Type de message de journalisation (par exemple, 'success', 'error', 'warning', 'debug')
* @param {string} message - Le message de journalisation
* @throws {Error} - Paramètres d'entrée invalides
*
* @example  &lt;caption>Tracer un succès&lt;/caption>
* general_logTrace('myFunction', 'success', 'Opération réussie');
* @example  &lt;caption>Tracer une erreur&lt;/caption>
* general_logTrace('myFunction', 'error', 'Erreur critique');
* @example  &lt;caption>Tracer un avertissement&lt;/caption>
* general_logTrace('myFunction', 'warning', 'Avertissement non critique');
* @example  &lt;caption>Tracer mon script pour debuger&lt;/caption>
* general_logTrace('myFunction', 'debug', 'Je vérifie l'execution de mon script');
*
* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 04/2023   | Thomas Heurtault  | Version initiale
* @since 2.0.0  | 01/2024   | Thomas Heurtault  | upd  TIA v19 - Addon jsConnector
* @since 3.0.0  | 03/2024   | Thomas Heurtault  | implement _config()
* @since 3.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc
**/
export function general_logTrace(functionName, type, message) {

    try {
        // Constantes pour les types de log
        const SUCCESS = 'success';
        const ERROR = 'error';
        const WARNING = 'warning';
        const DEBUG = 'debug';

        // Constantes pour les options de log
        const logOptions = {
            console: {
                [SUCCESS]: console.log,
                [ERROR]: console.error,
                [WARNING]: console.warn,
                [DEBUG]: console.log // Peut être ajusté en fonction des besoins
            },
            unified: {
                [SUCCESS]: 'HMIRuntime.Trace',
                [ERROR]: 'HMIRuntime.Trace',
                [WARNING]: 'HMIRuntime.Trace',
                [DEBUG]: 'HMIRuntime.Trace' // Peut être ajusté en fonction des besoins
            }
        };

        // Valider les paramètres d'entrée
        if (typeof functionName !== 'string' || typeof type !== 'string' || typeof message !== 'string') {
            throw new Error('Paramètres d\'entrée invalides');
        }

        // Obtenir les Tags globaux
        const { logToConsole, logToUnified, logDebug } = _config();

        // Obtenir la date et l'heure actuelles
        const date = new Date().toLocaleString();

        // Log message
        const logMessage = (logger, logType, logFunctionName, logMessage) => {
            eval(logger)(`${date} - ${logType} - ${logFunctionName}() - ${logMessage}`);
        };

        // Enregistrer dans la console si activé
        if (logToConsole &amp;&amp; logOptions.console[type]) {
            logMessage(logOptions.console[type], type.toUpperCase(), functionName, message);
        }

        // Enregistrer dans WinCC Unified si activé
        if (logToUnified &amp;&amp; logOptions.unified[type] &amp;&amp; (type !== DEBUG || logDebug)) {
            logMessage(logOptions.unified[type], type.toUpperCase(), functionName, message);
        }
    } catch (error) {
        // Enregistrer l'erreur dans la fonction
        console.error(` - ERROR - ${general_logTrace.name}() - ${error.message}`);
        // Relancer l'erreur vers la fonction appelante si nécessaire
        throw error;
    }
}
/**
    
 * 
 * @memberOf general
 * @function general_userAudit
 * @author Thomas HEURTAULT 
 * @version 3.0.1
 * @description Effectue des opérations d'audit en enregistrant des messages selon le type spécifié.
   
     * @param {'text' | 'bool' | 'analog'} type - Type d'audit (par exemple, 'text', 'bool', 'analog')
     * @param {string} message - Le message d'audit
     * @param {any} [oldValue] - La valeur précédente (utilisée pour 'bool' et 'analog')
     * @param {any} [newValue] - La nouvelle valeur (utilisée pour 'bool' et 'analog')
     * @throws {Error} - Paramètres d'entrée invalides
     
* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 04/2023   | Thomas Heurtault  | Version initiale
* @since 2.0.0  | 01/2024   | Thomas Heurtault  | upd  TIA v19 - Addon jsConnector
* @since 3.0.0  | 03/2024   | Thomas Heurtault  | implement _config()
* @since 3.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc
*/
export function general_userAudit(type, message, oldValue, newValue) {


    try {
        // Valider les paramètres d'entrée
        if (typeof type !== 'string' || typeof message !== 'string') {
            throw new Error('Paramètres d\'entrée invalides');
        }

        // Lire l'option d'audit utilisateur
        const { enableUserAudit } = _config();

        // Lire le nom d'utilisateur et le nom de la machine
        const userName = Tags("@UserName").Read();
        const localMachine = Tags("@LocalMachineName").Read();

        // Obtenir la date et l'heure actuelles
        const currentDate = new Date().toLocaleString();

        // Journaliser l'audit si l'option d'audit de l'utilisateur est activée
        if (enableUserAudit) {
            switch (type) {
                case 'text':
                    general_logTrace('general_userAudit', 'debug', `${localMachine} - AUDIT [${type}] : ${userName}: ${message}`);
                    HMIRuntime.Alarming.SysFct.CreateSystemInformation(`AUDIT [${type}] : ${userName} : ${message}`, localMachine);
                    break;
                case 'bool':
                case 'analog':
                    general_logTrace('general_userAudit', 'debug', `${localMachine} - AUDIT [${type}] : ${userName}: ${message} , oldValue = ${oldValue}, newValue = ${newValue}`);
                    HMIRuntime.Alarming.SysFct.CreateSystemInformation(`AUDIT [${type}] : ${userName}: , ${oldValue} -> ${newValue}`, localMachine, oldValue, newValue);
                    break;
                default:
                    general_logTrace('general_userAudit', 'warning', `'${type}' Type d'audit non reconnu`);
                    break;
            }
        }
    } catch (error) {
        // Lancer une exception en cas d'erreur
        general_logTrace("general_userAudit", "error", error);
        throw error;
    }

}
/**
* 
 * @memberOf general
 * @function general_waitForUiElement
 * @author Thomas HEURTAULT 
 * @version 2.0.1
 * @description  * Cette fonction attend qu'un élément d'interface utilisateur (UI) soit disponible sur l'écran actif
    * en fonction du chemin de l'élément spécifié (elementPath). La fonction vérifie périodiquement
    * l'existence de l'élément jusqu'à ce qu'il soit trouvé ou que le délai d'attente (timeout) soit dépassé.
    * 
    * @param {string} elementPath - Chemin de l'élément UI à rechercher sur l'écran actif
    * @param {number} [timeout=10000] - Délai d'attente maximal en millisecondes (par défaut : 10000 ms)
    * @returns {Promise&lt;Object>} - Promesse qui retoune l'élément trouvé ou rejette une erreur si le délai est dépassé
    * @throws {Error} - Erreur qui peut être levée en cas de problème lors de l'exécution de la fonction
    * 
* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 04/2023   | Thomas Heurtault  | Version initiale
* @since 2.0.0  | 01/2024   | Thomas Heurtault  | upd  TIA v19 - Addon jsConnector
* @since 2.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc 
*/
export function general_waitForUiElement(elementPath, timeout) {
    /** 
     * @const { number } CHECK_INTERVAL - Intervalle de vérification en ms
     * @default 100
     */
    const CHECK_INTERVAL = 100;

    // Vérification du délai et affectation par défaut si nécessaire
    // Checking the timeout and assigning a default value if necessary
    timeout = typeof timeout !== 'number' || isNaN(timeout) || timeout &lt;= 0 ? 10000 : timeout;

    // Création d'une promesse pour l'attente de l'élément UI
    // Creating a promise for waiting for the UI elemen
    return new Promise((resolve, reject) => {
        const startTime = Date.now();

        // Définition de l'intervalle de vérification avec une fonction de rappel
        // Setting the checking interval with a callback function
        const intervalId = HMIRuntime.Timers.SetInterval(() => {
            if (UI.ActiveScreen) {
                const item = UI.ActiveScreen.FindItem(elementPath);

                // Résoudre la promesse si l'élément est trouvé
                // Resolve the promise if the element is found
                if (item) {
                    HMIRuntime.Timers.ClearInterval(intervalId);
                    resolve(item);
                }
                // Rejeter la promesse si le délai est dépassé
                // Reject the promise if the timeout is exceeded
            } else if (Date.now() - startTime > timeout) {
                HMIRuntime.Timers.ClearInterval(intervalId);
                general_logTrace("general_waitForUiElement", "warning", `L'élément '${elementPath}' n'a pas été trouvé dans le délai imparti (${timeout}ms)`);
                reject(new Error(`L'élément '${elementPath}' n'a pas été trouvé dans le délai imparti (${timeout}ms)`));
            }
        }, CHECK_INTERVAL); // Vérifie toutes les 100 millisecondes 
    });

}
/**
 *  @memberOf global
* @function _initRuntime
* @author Thomas HEURTAULT 
* @version 2.0.1
* @description Cette fonction initialise des paramètres au lancement de la page web.

* @throws {Error} 

* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 04/2023   | Thomas Heurtault  | Version initiale
* @since 2.0.0  | 01/2024   | Thomas Heurtault  | upd  TIA v19 - Addon jsConnector
* @since 2.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc

*/
export function _initRuntime() {

    try {
        // Créer un tableau de promesses pour chaque fonction asynchrone que vous appelez
        const promises = [
            // Définir le nœud racine de l'objet "Plant_Hierarchy" sur "ACCUEIL"
            screenLayout_setHierarchyNodes("@_corporate_designer/01_agromousquetaires/visual_identity/AGROM_Accueil")
        ];

        // Utiliser Promise.all pour attendre que toutes les promesses soient résolues
        Promise.all(promises)
            .then(() => {
                // Journalise la réussite de l'initialisation une fois que toutes les promesses sont résolues
                const messageLog = `Initialisation de l'OS terminée`;
                general_logTrace(_initRuntime.name, 'success', messageLog);
            })
            .catch((error) => {
                // En cas d'erreur lors de l'exécution des promesses
                const messageLog = `Erreur lors de l'initialisation : ${error}`;
                general_logTrace(_initRuntime.name, 'error', messageLog);
                throw error;
            });
    } catch (error) {
        // En cas d'erreur inattendue
        const messageLog = `Erreur inattendue : ${error}`;
        general_logTrace(_initRuntime.name, 'error', messageLog);
        throw error;
    }



}
/**
 * @memberOf screenLayout
* @function screenLayout_getHierarchyFirstLevel()
* @author Thomas HEURTAULT 
* @version 2.0.1
* @description  Cette fonction, filtre les objets "LTU_PO_Screen" de Plant Object,pour récupérer les chemins
 * contenant exactement un seul '/' et ne contenant pas le caractère '@'.
 * Elle renvoie ensuite une liste d'objets contenant le chemin et le nom extraits de ces objets filtrés.
 *
 * @returns {Array} - Un tableau d'objets contenant les chemins des PO et leur noms filtrés.
 * @throws {Error} 
 * 

* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 10/2023   | Thomas Heurtault  | Version initiale
* @since 2.0.0  | 01/2024   | Thomas Heurtault  | upd  TIA v19 - Addon jsConnector - PO type = "LTU_PO_Screen" - Optimisation
* @since 2.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc
*/
export function screenLayout_getHierarchyFirstLevel() {

    try {
        // Récupérer les objets "LTU_PO_Screen" de Plant Object
        const PO_SynoptiqueArray = PlantModel.GetPlantObjectsByType("LTU_PO_Screen");

        // Vérifier s'il y a des objets à traiter
        if (PO_SynoptiqueArray.length === 0) {
            general_logTrace("screenLayout_getHierarchyFirstLevel", "warning", "Aucun élément de niveau supérieur trouvé. (01)");
            return [];
        }

        // Fonction utilitaire pour traiter chaque objet synoptique
        const processSynoptique = (synoptique) => {
            // Récupérer le chemin du synoptique
            const path = synoptique.PlantViewPaths['hierarchy'];
            general_logTrace("screenLayout_getHierarchyFirstLevel", "debug", `Path : ${path}`);
            // Vérifier si le chemin contient exactement un seul '/' et ne contient pas '@'
            const segments = path.split('/');
            if (segments.length === 2 &amp;&amp; !segments[1].includes('@')) {
                // Extraire le nom du synoptique à partir du chemin
                const name = segments[1];
                general_logTrace("screenLayout_getHierarchyFirstLevel", "debug", `Path : ${path} , Name : ${name}`);
                return { path, name };
            }
            return null; // Ignorer les chemins invalides
        };

        // Appliquer la fonction utilitaire à chaque objet synoptique et filtrer les résultats non nuls
        const topLevelElements = PO_SynoptiqueArray.map(processSynoptique).filter(Boolean);

        // Afficher les résultats sous forme de tableau
        if (topLevelElements.length > 0) {
            console.table(topLevelElements);
            for (let element of topLevelElements) {
                general_logTrace("screenLayout_getHierarchyFirstLevel", "debug", `Path : ${element.path}, Name : ${element.name}`);
            }
            general_logTrace("screenLayout_getHierarchyFirstLevel", "success", ".");
        } else {
            general_logTrace("screenLayout_getHierarchyFirstLevel", "warning", "Aucun élément de niveau supérieur trouvé. (02)");
        }

        return topLevelElements;
    } catch (error) {
        // Gérer les erreurs et propager l'exception
        general_logTrace("screenLayout_getHierarchyFirstLevel", "error", error);
        throw error;
    }


}
/**
 * @memberOf screenLayout
* @function screenLayout_setHierarchyNodes
* @async
* @author Thomas HEURTAULT 
* @version 2.0.1
* @description  Cette fonction définit le nœud racine de l'objet "Plant_Navigation" et sélectionne un objet de vue.
*
  * @param {string} [RootNodeName=""] - Nom du nœud à utiliser comme racine de navigation.
    * @returns {Promise&lt;void>} - Promesse résolue lors de la définition du nœud racine et de la sélection de la vue.
    * @throws {Error} - 
   * @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 10/2023   | Thomas Heurtault  | Version initiale
* @since 2.0.0  | 01/2024   | Thomas Heurtault  | upd  TIA v19 - Addon jsConnector
* @since 2.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc


    */
export async function screenLayout_setHierarchyNodes(rootNodeName) {

    /** 
     * @const { string } PLANT_HIERARCHY_PATH - // Chemin de la fenêtre de vue principale
     * @default "~/@Menu" 
     */
    const PLANT_HIERARCHY_PATH = "~/@Menu";
    let nodeName = (rootNodeName === undefined) ? "" : rootNodeName;

    try {
        const element = await screenLayout_getHierarchyInfos();
        const element_bis = await general_waitForUiElement(PLANT_HIERARCHY_PATH, 2000);

        let rootNodePath, selectedNodePath;
        if (nodeName === "") {
            // CHARGER LE PREMIER NIVEAU DE LA HIÉRARCHIE ET SÉLECTIONNER LA PREMIÈRE VUE
            rootNodePath = `${element.HierarchyPrefix}::${element.HierarchyName}`;
            selectedNodePath = element.FirstSynoptiquePath;
            general_logTrace(screenLayout_setHierarchyNodes.name, 'debug', `rootNodePath: ${rootNodePath}, selectedNodePath: ${selectedNodePath}`);
        } else {
            // CHARGER UN NŒUD DE HIÉRARCHIE COMME RACINE ET SÉLECTIONNER LA PREMIÈRE VUE
            rootNodePath = `${element.HierarchyPrefix}::${element.HierarchyName}/${nodeName}`;
            selectedNodePath = `${element.RuntimePrefix}${element.HierarchyPrefix}::${element.HierarchyName}/${nodeName}`;
            general_logTrace(screenLayout_setHierarchyNodes.name, 'debug', `rootNodePath: ${rootNodePath}, selectedNodePath: ${selectedNodePath}`);
        }

        // Configure les propriétés de l'élément UI
        element_bis.Properties.SelectedNode = selectedNodePath;
        element_bis.Properties.RootNode = rootNodePath;
        const messageLog = `Mise à jour PlantObject terminée`;
        general_logTrace(screenLayout_setHierarchyNodes.name, 'success', messageLog);
    } catch (error) {
        general_logTrace(screenLayout_setHierarchyNodes.name, 'error', error);
        throw error; // Rejette la promesse en cas d'erreur
    }


}
/**
 *  @memberOf screenLayout
* @function screenLayout_setTopLevelNavigation
* @async
* @author Thomas HEURTAULT 
* @version 3.0.1
* @description Cette fonction configure les boutons de navigation pour les éléments de niveau supérieur de la hiérarchie des objets "Synoptique" de Plant Object.
  * Elle filtre ces objets en recherchant ceux dont le chemin contient exactement un seul '/' et configure les boutons de navigation correspondants.
  * 
   * @returns {void} - Cette fonction ne renvoie pas de valeur.
  * @throws {Error} - Erreur qui peut être levée en cas de problème lors de l'exécution de la fonction.

* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 10/2023   | Thomas Heurtault  | version initiale
* @since 2.0.0  | 10/2024   | Thomas Heurtault  | add navigation extended
* @since 3.0.0  | 01/2024   | Thomas Heurtault  | upd  TIA v19 - Addon jsConnector
* @since 3.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc
  */
export async function screenLayout_setTopLevelNavigation() {
    /** 
     * @const { string } SCREEN_TOP_LVL_NAV_PATH 
     * @default ~/FV_@Header/FV_@Navigation/
     */
    /** 
     * @const { string } SCREEN_EXTENDED_NAV_PATH 
     * @default ~~/FV_@NavigationExtended/
     */
    /** 
     * @const { string } PREFIX_BP 
     * @default BP_Nav_
     */
    /** 
     * @const { number } MAX_BP
     * @default 7
     */
    /** 
     * @const { number } MAX_BP_EXTENDED - MAX_BP + 8
     * @default 8
     */
    const SCREEN_TOP_LVL_NAV_PATH = "~/FV_@Header/FV_@Navigation/";
    const SCREEN_EXTENDED_NAV_PATH = "~/FV_@NavigationExtended/";
    const PREFIX_BP = "BP_Nav_";
    const MAX_BP = 7;
    const MAX_BP_EXTENDED = MAX_BP + 8;

    async function configureButton(element, buttonId) {
        const thisBP = await general_waitForUiElement(buttonId, 2000);
        if (!thisBP) {
            general_logTrace("screenLayout_setTopLevelNavigation", "warning", `Élément introuvable : ${buttonId}`);
            return;
        }
        thisBP.Text = element.name;
        thisBP.AlternateText = element.path;
        thisBP.Visible = true;
    }

    try {
        const topLevelElements = await screenLayout_getHierarchyFirstLevel();

        if (topLevelElements.length === 0) {
            general_logTrace("screenLayout_setTopLevelNavigation", "warning", "Aucun élément de niveau supérieur trouvé.");
            return;
        }

        for (let i = 0; i &lt; topLevelElements.length; i++) {
            const element = topLevelElements[i];
            general_logTrace("screenLayout_setTopLevelNavigation", "debug", `[${i}] = ${element.name}, ${element.path}`);

            const thisBPId = `${SCREEN_TOP_LVL_NAV_PATH}${PREFIX_BP}${i}`;
            if (i &lt; MAX_BP) {
                await configureButton(element, thisBPId);
            } else if (i &lt; MAX_BP_EXTENDED) {
                const extendedElement = await general_waitForUiElement(`${SCREEN_TOP_LVL_NAV_PATH}BP_Nav_Extended`, 2000);
                if (extendedElement) {
                    extendedElement.Visible = true;
                    await configureButton(element, `${SCREEN_EXTENDED_NAV_PATH}${PREFIX_BP}${i}`);
                }
            } else {
                general_logTrace("screenLayout_setTopLevelNavigation", "warning", "Le nombre d'éléments TopLevel dépasse le nombre max de boutons de navigation");
                general_logTrace("screenLayout_setTopLevelNavigation", "debug", `[${i}] = ${element.name}, ${element.path}`);
            }
        }
    } catch (error) {
        general_logTrace("screenLayout_setTopLevelNavigation", "error", error);
        throw new Error("Erreur lors de la configuration des boutons de navigation de niveau supérieur.");
    }
}
/**
* @memberOf screenHistory
* @function screenHistory_changeScreen
* @author Thomas HEURTAULT 
* @version 1.0.1
* @description  Cette fonction gère l'historique de navigation.
 * Elle ajoute le nom de l'écran actuel à l'historique, vide la pile de navigation suivant, et met à jour l'état des boutons de navigation.

 * @param {string} screenName - Nom de l'écran vers lequel naviguer.
 * @throws {Error}
 * 
 * @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 03/2024   | Thomas Heurtault  | version initiale
* @since 1.0.1  | 01/2024   | Thomas Heurtault  | implement JSDoc

*/
export function screenHistory_changeScreen(screenName) {
    try {
        /** 
     * @const { number } MAX_HISTORY_SIZE - Taille maximale de l'historique de navigation
     * @default 10 
     */
        const MAX_HISTORY_SIZE = 10;

        // Assurez-vous que les DataSets nécessaires sont créés
        screenHistory_createStackDataset();

        // Récupérer les piles d'historique et l'état de la navigation depuis les DataSets
        let historyStack = UI.DataSet.Item("screenHistory_historyStack");
        let forwardStack = UI.DataSet.Item("screenHistory_forwardStack");
        let isButtonNavigation = UI.DataSet.Item("screenHistory_isButtonNavigation");

        //Exécution si la navigation est déclenchée par autre chose que les boutons précédent/suivant
        if (isButtonNavigation === 0) {
            // Si la taille de l'historique dépasse la taille maximale, supprime le premier élément
            general_logTrace("screenHistory_changeScreen", "debug", `historyStack.length = ${historyStack.length}`)
            if (historyStack.length >= MAX_HISTORY_SIZE) {
                historyStack.shift();
                general_logTrace("screenHistory_changeScreen", "warning", `MAX_HISTORY_SIZE atteint, suppression du premier élément`);
            }

            // Ajoute le nouvel écran à l'historique
            // Met à jour le DataSet avec le nouvel historique
            historyStack.push(screenName);
            UI.DataSet.Add("screenHistory_historyStack", historyStack);
            general_logTrace("screenHistory_changeScreen", "debug", `Push ${screenName} à l'historique`);

            // Vide la pile forwardStack
            forwardStack = [];
            UI.DataSet.Add("screenHistory_forwardStack", forwardStack);

        }

        // Réinitialise le tag de changement via les boutons précédent/suivant
        // Met à jour l'état des boutons de navigation
        UI.DataSet.Add("screenHistory_isButtonNavigation", 0);
        screenHistory_updateButtonState();

        general_logTrace("screenHistory_changeScreen", "success", ".");
    } catch (error) {
        // Gérer les erreurs et propager l'exception
        general_logTrace("screenHistory_changeScreen", "error", error);
        throw error;
    }
}
/**
*  @memberOf screenHistory
* @function screenHistory_goBackScreen
* @author Thomas HEURTAULT 
* @version 1.0.1
* @description Cette fonction est responsable de naviguer vers l'écran précédent dans l'historique de navigation.
 * Elle récupère les DataSets d'historique et de pile avant, déplace l'état actuel vers la pile avant,
 * charge l'écran précédent depuis l'historique et effectue le changement d'écran.
 * Cette fonction est généralement appelée lorsque l'utilisateur appuie sur le bouton de retour.
 * 
 * @throws {Error} - Erreur qui peut être levée en cas de problème lors de la navigation vers l'écran précédent.
* 
* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 03/2024   | Thomas Heurtault  | version initiale
* @since 1.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc
 * 
*/
export function screenHistory_goBackScreen() {
    /** 
   * @const { string } SCREEN_MAIN 
   * @default //FV_@Main
   */
    const SCREEN_MAIN = "//FV_@Main";

    try {
        // Assurez-vous que les DataSets nécessaires sont créés
        screenHistory_createStackDataset();

        let historyStack = UI.DataSet.Item("screenHistory_historyStack");
        let forwardStack = UI.DataSet.Item("screenHistory_forwardStack");
        // Définir l'indicateur de navigation bouton sur 1 (inhibition de la mise à jour des pile dans la fonction changeScreen)
        UI.DataSet.Add("screenHistory_isButtonNavigation", 1);

        if (historyStack.length > 1) {
            // Retirer l'état actuel de l'historique et le mettre dans l'historique avant
            forwardStack.push(historyStack.pop());
            // Mettre à jour les DataSets avec les nouvelles piles d'historique et de pile avant
            UI.DataSet.Add("screenHistory_forwardStack", forwardStack);
            UI.DataSet.Add("screenHistory_historyStack", historyStack);
            // Charger l'état précédent depuis l'historique
            let previousScreen = historyStack.pop();
            UI.SysFct.ChangeScreen(previousScreen, SCREEN_MAIN);
        }
        general_logTrace("screenHistory_goBackScreen", "success", ".");
    } catch (error) {
        // Gérer les erreurs et propager l'exception
        general_logTrace("screenHistory_goBackScreen", "error", error);
        throw error;
    }
}
/**
 *  @memberOf screenHistory
* @function screenHistory_goForwardScreen
* @author Thomas HEURTAULT 
* @version 1.0.1
* @description  Cette fonction est responsable de naviguer vers l'écran suivant dans l'historique de navigation.
 * Elle récupère les DataSets d'historique et de pile avant, déplace l'état suivant vers l'historique,
 * charge l'écran suivant depuis la pile avant et effectue le changement d'écran.
 * Cette fonction est généralement appelée lorsque l'utilisateur appuie sur le bouton de navigation vers l'avant.
*
 *  @throws {Error} - Erreur qui peut être levée en cas de problème lors de la navigation vers l'écran suivant
 * 
* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 03/2024   | Thomas Heurtault  | version initiale
* @since 1.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc

 *
.
*/
export function screenHistory_goForwardScreen() {
    /** 
     * @const { string } SCREEN_MAIN 
     * @default //FV_@Main
     */
    const SCREEN_MAIN = "//FV_@Main";

    try {
        // Assurez-vous que les DataSets nécessaires sont créés
        screenHistory_createStackDataset();

        let historyStack = UI.DataSet.Item("screenHistory_historyStack");
        let forwardStack = UI.DataSet.Item("screenHistory_forwardStack");

        // Définir l'indicateur de navigation bouton sur 1 (inhibition de la mise à jour des pile dans la fonction changeScreen)
        UI.DataSet.Add("screenHistory_isButtonNavigation", 1);

        if (forwardStack.length > 0) {
            // Retirer l'état actuel de l'historique avant et le remettre dans l'historique
            historyStack.push(forwardStack.pop());
            // Mettre à jour les DataSets avec les nouvelles piles d'historique et de pile avant
            UI.DataSet.Add("screenHistory_forwardStack", forwardStack);
            UI.DataSet.Add("screenHistory_historyStack", historyStack);
            // Charger l'état suivant depuis l'historique avant
            let nextScreen = historyStack[historyStack.length - 1];
            UI.SysFct.ChangeScreen(nextScreen, SCREEN_MAIN);
        }

        general_logTrace("screenHistory_goForwardScreen", "success", ".");
    } catch (error) {
        // Gérer les erreurs et propager l'exception
        general_logTrace("screenHistory_goForwardScreen", "error", error);
        throw error;
    }

}
/**
 *   @memberOf screenHistory
* @function screenHistory_createStackDataset
* @author Thomas HEURTAULT 
* @version 1.0.1
* @description   Cette fonction crée les DataSets nécessaires pour stocker l'historique de navigation.
 * Si les DataSets n'existent pas déjà, ils sont créés avec des tableaux vides pour stocker l'historique et la pile avant.
 * Cette fonction est généralement appelée au démarrage de l'application pour initialiser les DataSets.
*
 *  @throws {Error} - Erreur qui peut être levée en cas de problème lors de la navigation vers l'écran suivant
 * 
* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 03/2024   | Thomas Heurtault  | version initiale
* @since 1.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc
 *
*/
export function screenHistory_createStackDataset() {
    try {

        // Vérifier si le DataSet "screenHistory_historyStack" existe, sinon le créer
        if (!UI.DataSet.Exists("screenHistory_historyStack")) {
            general_logTrace("screenHistory_createStackDataset", "debug", `create Dataset historyStack `);
            UI.DataSet.Add("screenHistory_historyStack", []);
        }
        // Vérifier si le DataSet "screenHistory_forwardStack" existe, sinon le créer
        if (!UI.DataSet.Exists("screenHistory_forwardStack")) {
            general_logTrace("screenHistory_createStackDataset", "debug", `create Dataset forwardStack `);
            UI.DataSet.Add("screenHistory_forwardStack", []);
        }
        // Vérifier si le DataSet "screenHistory_isButtonNavigation" existe, sinon le créer
        if (!UI.DataSet.Exists("screenHistory_isButtonNavigation")) {
            general_logTrace("screenHistory_createStackDataset", "debug", `create Dataset forwardStack `);
            UI.DataSet.Add("screenHistory_isButtonNavigation", 0);
        }

        general_logTrace("screenHistory_createStackDataset", "success", ".");
    } catch (error) {
        // Gérer les erreurs et propager l'exception
        general_logTrace("screenHistory_createStackDataset", "error", error);
        throw error;
    }
}
/**
 *  @memberOf screenHistory
* @function screenHistory_updateButtonState
* @author Thomas HEURTAULT 
* @version 1.0.1
* @description   Cette fonction est responsable de mettre à jour l'état des boutons de navigation précédent/suivant de l'interface utilisateur.
 * Elle récupère les DataSets d'historique et de pile avant pour déterminer si les boutons précédent et suivant doivent être activés ou désactivés.
 * Cette fonction est généralement appelée après un changement d'écran pour mettre à jour l'état des boutons de navigation.
*
 *  @throws {Error} - Erreur qui peut être levée en cas de problème lors de la mise à jour de l'état des boutons.
 * 
* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 03/2024   | Thomas Heurtault  | version initiale
* @since 1.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc
 *
 * 
*/
export function screenHistory_updateButtonState() {
    try {
        // Recherche des boutons précédent et suivant dans l'interface utilisateur
        const backButton = UI.FindItem("//FV_@ScreenHistory_Navigation/BP_BackScreen");
        const forwardButton = UI.FindItem("//FV_@ScreenHistory_Navigation/BP_ForwardScreen");
        if (!backButton || !forwardButton) {
            throw new Error("Les boutons de navigation précédent/suivant n'ont pas été trouvés dans l'interface utilisateur.");
        }
        // Récupération des piles d'historique et de pile avant
        let historyStack = UI.DataSet.Item("screenHistory_historyStack");
        let forwardStack = UI.DataSet.Item("screenHistory_forwardStack");
        if (!historyStack || !forwardStack) {
            throw new Error("Les datasets d'historique et de pile avant n'ont pas été trouvés.");
        }

        // Vérifiez l'état des piles correspondantes et activez/désactivez les boutons en conséquence
        backButton.Enabled = historyStack.length > 1; // Activez le bouton précédent
        forwardButton.Enabled = forwardStack.length > 0; // Activez le bouton suivant

        general_logTrace("screenHistory_updateButtonState", "success", ".");
    } catch (error) {
        // Gérer les erreurs et propager l'exception
        general_logTrace("screenHistory_updateButtonState", "error", error);
        throw error;
    }





}
/**
 * @memberOf global
* @function _config
* @author Thomas HEURTAULT 
* @version 3.0.1
* @description Description de ma fonction
*
* @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 03/2024   | Thomas Heurtault  | version initiale
* @since 1.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc
*/
export function _config() {

    const _config = {

        // OS type 
        OStype: false, // false = Windows (PC) , true = Linux (UCP)    

        // general_logTrace.js
        logToConsole: false,    // Activer les logs dans la console , uniquement en développement
        logToUnified: true,     // Activer les logs dans TraceViewer (unified) 
        logDebug: true,         // Activer les logs de debug , uniquement en développement

        //general_userAudit.js 
        enableUserAudit: true,     // Activer l'outil d'audit utilisateur 

        //Reporting - tasks planned
        enableReporting: true,               // Activer l'outil de reporting
        enbaleReporting_SystemFault: true,   // Activer le rapport automatique sur défaut système (task planned)
    };
    return _config;
}
/**
 * @memberOf screenLayout
* @function screenLayout_getHierarchyInfos
* @author Thomas HEURTAULT 
* @version 2.0.1
* @description Cette fonction récupère des informations à partir d'un objet PlantNavigation.
 * Elle extrait les informations telles que le chemin du premier objet Synoptique,
 * le préfixe d'exécution, le préfixe de la hiérarchie et le nom de la hiérarchie.
 * 
 * @returns {Promise&lt;Object>} - Une promesse qui résout un objet contenant les informations extraites ou rejette une erreur en cas de problème.
 * @throws {Error} - Erreur qui peut être levée en cas de problème lors de l'exécution de la fonction.
 * 
 * @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 10/2023   | Thomas Heurtault  | version initiale
* @since 2.0.0  | 01/2024   | Thomas Heurtault  | upd  TIA v19 - Addon jsConnector - PO type = "LTU_PO_Screen"
* @since 2.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc
*
 */
export function screenLayout_getHierarchyInfos() {
    return new Promise((resolve, reject) => {
        // Récupère tous les éléments "Synoptique" de Plant Object
        const PO_SynoptiqueArray = PlantModel.GetPlantObjectsByType("LTU_PO_Screen");

        if (PO_SynoptiqueArray.length > 0) {
            // Récupère le chemin du premier objet dans la hiérarchie
            const PO_FirstSynoptiquePath = PO_SynoptiqueArray[0].PlantViewPaths['hierarchy'];
            // Récupère le préfixe du runtime tel que 'W203PRUP400_RT'
            const HmiRuntimePrefix = PO_FirstSynoptiquePath.slice(0, PO_FirstSynoptiquePath.indexOf('.'));
            // Récupère le préfixe de hiérarchie comme 'hiérarchie', fixe dans la V17
            const PO_HierarchyPrefix = PO_FirstSynoptiquePath.slice(PO_FirstSynoptiquePath.indexOf('.'), PO_FirstSynoptiquePath.indexOf(':'));
            // Obtient le nom de la hiérarchie comme 'MON USINE'
            const PO_HierarchyName = PO_FirstSynoptiquePath.slice(PO_FirstSynoptiquePath.indexOf(':') + 2, PO_FirstSynoptiquePath.indexOf('/'));

            // Créez un objet pour stocker les informations et résolvez la promesse
            const plantObjectInfo = {
                FirstSynoptiquePath: PO_FirstSynoptiquePath,
                RuntimePrefix: HmiRuntimePrefix,
                HierarchyPrefix: PO_HierarchyPrefix,
                HierarchyName: PO_HierarchyName
            };
            general_logTrace(screenLayout_getHierarchyInfos.name, "debug", `FirstSynoptiquePath: ${plantObjectInfo.FirstSynoptiquePath}`);
            general_logTrace(screenLayout_getHierarchyInfos.name, "debug", `RuntimePrefix: ${plantObjectInfo.RuntimePrefix}`);
            general_logTrace(screenLayout_getHierarchyInfos.name, "debug", `HierarchyPrefix: ${plantObjectInfo.HierarchyPrefix}`);
            general_logTrace(screenLayout_getHierarchyInfos.name, "debug", `HierarchyName: ${plantObjectInfo.HierarchyName}`);

            resolve(plantObjectInfo);
        } else {
            general_logTrace(screenLayout_getHierarchyInfos.name, 'warning', `Aucun objet LTU_PO_Screen trouvé dans la hiérarchie.`);
            reject(new Error("Aucun objet LTU_PO_Screen trouvé dans la hiérarchie."));
        }
    });
}
/**
 * @memberOf screenLayout
* @function screenLayout_setSecondLevelNavigation
@async
* @author Thomas HEURTAULT 
* @version 1.0.1
* @description Cette fonction parcourt les éléments de navigation de second niveau fournis, puis les associe aux boutons de navigation correspondants sur l'écran actif.
 * Si le nombre d'éléments de navigation est inférieur au nombre maximal de boutons de navigation de second niveau, les boutons excédentaires sont masqués.
 *
 * @param {string} screenName - Le nom de l'écran sur lequel configurer la navigation de second niveau.
 * @param {Array} secondLvlNav - Le tableau des éléments de navigation de second niveau.
 * @returns {void} - Cette fonction ne renvoie pas de valeur.
 * @throws {Error} - Erreur qui peut être levée en cas de problème lors de l'exécution de la fonction.
 * 
 * @since 0.0.0  | Date      | Auteur            | Modification(s)
* @since 1.0.0  | 03/2024   | Thomas Heurtault  | version initiale
* @since 1.0.1  | 03/2024   | Thomas Heurtault  | implement JSDoc
 * 
 */
export async function screenLayout_setSecondLevelNavigation(screenName, secondLvlNav) {
    // Constantes pour les boutons de navigation de second niveau
    const SCREEN_MAIN = "//FV_@Main";
    const SCREEN_SECOND_LVL_NAV_PATH = "~/FV_@navigation_second_lvl/";
    const PREFIX_BP = "BP_SubNav_";
    const MAX_BP = 27;


    /**
     * Configure un bouton de navigation de second niveau avec les données fournies.
     * @param {Object} element - Objet représentant l'élément de navigation.
     * @param {string} buttonId - ID du bouton de navigation.
     */
    async function configureButton(element, buttonId) {
        const thisBP = await general_waitForUiElement(buttonId, 2000);
        if (!thisBP) {
            general_logTrace("screenLayout_setTopLevelNavigation", "warning", `Élément introuvable : ${buttonId}`);
            return;
        }
        thisBP.Text = element.name;
        thisBP.AlternateText = element.path;
        thisBP.Visible = true;
    }

    /**
     * Configure la navigation de second niveau pour l'écran spécifié.
     * @param {string} screenName - Nom de l'écran.
     * @param {Array} secondLvlNav - Tableau des éléments de navigation de second niveau.
     */
    try {
        // Validation des données d'entrée
        if (!screenName || !secondLvlNav || !secondLvlNav.length) {
            throw new Error("Les données d'entrée sont invalides.");
        }

        // Changement de vue
        if (screenName !== "screenName" || screenName !== "") {
            UI.SysFct.ChangeScreen(screenName, SCREEN_MAIN);
            general_logTrace("screenLayout_setSecondLevelNavigation", "success", `Changement de vue réussi : ${screenName}`);
        } else {
            general_logTrace("screenLayout_setSecondLevelNavigation", "error", `Changement de vue échoué : ${screenName}`);
        }

        // Configuration des boutons de navigation
        for (let i = 0; i &lt; secondLvlNav.length &amp;&amp; i &lt; MAX_BP; i++) {
            const element = secondLvlNav[i];
            const thisBPId = `${SCREEN_SECOND_LVL_NAV_PATH}${PREFIX_BP}${i}`;
            await configureButton(element, thisBPId);
            general_logTrace("screenLayout_setSecondLevelNavigation", "debug", `[${i}] = ${element.name}, ${element.path}`);
        }

        // Masquage des boutons supplémentaires
        for (let i = secondLvlNav.length; i &lt; MAX_BP; i++) {
            const thisBPId = `${SCREEN_SECOND_LVL_NAV_PATH}${PREFIX_BP}${i}`;
            const thisBP = await general_waitForUiElement(thisBPId, 500);
            if (thisBP) {
                thisBP.Visible = false;
                general_logTrace("screenLayout_setSecondLevelNavigation", "debug", `${thisBPId} masqué`);
            } else {
                general_logTrace("screenLayout_setSecondLevelNavigation", "warning", `Élément introuvable : ${thisBPId}`);
            }
        }
    } catch (error) {
        general_logTrace("screenLayout_setSecondLevelNavigation", "error", error);
        throw error;
    }

}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Fri Mar 29 2024 18:10:57 GMT+0100 (heure normale d’Europe centrale) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
